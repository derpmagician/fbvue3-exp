import{H as D,r as y,x as g,y as U,z as d,I as w,J as u,K as p,L as f,M as v,N as h,O as m,E as C,P as S}from"./index-1ddce23d.js";const O=D("colUrls",()=>{let t=y([]),i=y(!1);return{documents:t,loadingDoc:i,getColUrls:async()=>{i.value=!0;try{const s=g(U(d,"colUrls"),w("users","array-contains",u.currentUser.uid));(await p(s)).forEach(o=>{t.value.push({id:o.id,...o.data()})})}catch(s){console.log(s)}finally{i.value=!1}},leerColUrl:async s=>{i.value=!0;try{const e=f(d,"colUrls",s),o=await v(e);if(!o.exists())throw new Error("doc no existe");return o.data().longUrl}catch(e){console.log(e.message)}finally{i.value=!1}},addColUrl:async s=>{try{const e=U(d,"colUrls");let o;const r=g(U(d,"colUrls"),w("longUrl","==",s)),a=await p(r);if(a.empty){const l={longUrl:s,users:[u.currentUser.uid]},c=await C(e,l),n=c.id;await h(c,{shortUrl:n}),t.value.push({id:n,...l,shortUrl:n})}else{const l=f(d,"colUrls",a.docs[0].id);await h(l,{users:m(u.currentUser.uid)});const c={id:a.docs[0].id,...a.docs[0].data(),users:[...a.docs[0].data().users,u.currentUser.uid]},n=t.value.findIndex(x=>x.id===c.id);n!==-1?t.value[n]=c:t.value.push(c)}}catch(e){console.log(e)}},deleteColUrl:async s=>{try{const e=f(d,"colUrls",s),o=await v(e);if(!o.exists())throw new Error("Document does not exist");const r=o.data().users,a=r.indexOf(u.currentUser.uid);if(a===-1)throw new Error("User is not in the document");r.splice(a,1),r.length===0?await S(e):await h(e,{users:r});const l=t.value.findIndex(c=>c.id===s);l!==-1&&(r.length===0?t.value.splice(l,1):t.value[l]={id:s,...o.data(),users:r})}catch(e){console.log(e.message)}}}});export{O as u};
